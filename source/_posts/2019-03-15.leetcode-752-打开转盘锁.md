---
layout: post
title:  leetcode第752题-打开转盘锁
tags:
	- arithmetic
categories:
	- arithmetic
date:  2019-03-15
description: 分析一下BFS的经典算法
comments: true
---
	打开转盘锁，是一个利用BFS探索最短路径的一道算法题。
		1.题目内容：
		你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为  '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。
		锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。
		列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
	字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。
		
		2.思路：
		根据题目描述能够看出来这是一道很明显利用BFS去求最短路径的题。首先，这个题需要解决的难点在于：
		①如何找到每一个当前锁值的所有下一步路径。(目的在于确定每一步能产生的所有锁情况)：
		利用循环遍历当前锁值的每一个字符位置。判断该位置字符的数字大小，因为每一步能产生的操作只能是+1或-1，对每一个字符产生一个+1操作和一个-1操作。但小心特殊情况！当该字符为9时，它的正向操作的下一步结果为0！而当该字符为0时，它的反向操作的下一步结果为9！
		②如何筛选出重复产生的锁值(利用Set集合的特性)
		③如何绕过deadends死亡数字(deadends数组的作用在于阻断路线，所以当锁值是死亡数字之后，排除即可)。

		3.代码及解析：
		```java
		import java.util.*;
		import java.lang.StringBuilder;
	/**
	 思路：运用BFS的思想，进行每一层的检索.限制条件：deadends死锁路径限制
	 */
	class Solution {
	    public int openLock(String[] deadends, String target) {
	        //将deadends死锁的值存入set进行去重处理以及后续判断
	        Set<String> sets = new HashSet<>(Arrays.asList(deadends));
	        //判断target是否存在deadends死锁中，如果存在，直接死锁
	        //判断'0000'是否存在在死锁中，如果存在，起步则死锁
	        if(sets.contains(target) || sets.contains("0000")){
	            return -1;
	        }
	        //去除重复的队列，只有不存在在此队列里的路径才能进入下一层
	        Set<String> removeDuplication = new HashSet();
	        //需要处理的当前层
	        Queue<String> currentLayer = new LinkedList<>();
	        //处理当前层时需要将当前层的邻居放入的位置，也就是若当前层没有找到正确的锁值，接下来访问的一层
	        Queue<String> nextLayer = new LinkedList<>();
	        //记录步数
	        int step = 0;
	        //放入锁的起始值'0000'
	        currentLayer.offer("0000");
	        //如果当前层没有值，说明锁的全路径已经遍历完。找不到的原因是因为死锁的路径被封死。
	        while(!currentLayer.isEmpty()){
	            //按顺序取出当前层的每一个锁，尝试打开
	            String currentLock = currentLayer.poll();
	            //当前拨弄的锁值是否可以解锁，如果可解锁即开锁成功。
	            if(currentLock.equals(target)){
	                return step;
	            }
	            //当前锁值的所有邻居
	            Queue<String> lockFriend = getFriend(currentLock);
	            for(String value : lockFriend){
	                if(!sets.contains(value) && !removeDuplication.contains(value)){
	                    //将不重复的锁值路径存入判断非重复的锁值队列中
	                    removeDuplication.add(value);
	                    //将锁值存入下一层队列
	                    nextLayer.offer(value);
	                }
	            }
            //当前层已空，说明未找到正确的开锁值，那么为下一层开锁测试做准备
            if(currentLayer.isEmpty()){
                //将此层锁值的邻居也就是下一层赋予当前层
                currentLayer = nextLayer;
                //每一层走完所有情况+1
                step++;
                //更新下一层
                nextLayer = new LinkedList<>();
            }
        }
        return -1;
    }
    public Queue getFriend(String currentLock){
        Queue<String> friend = new LinkedList<>();
        for(int i = 0; i < 4; i++){
            StringBuilder sb = new StringBuilder(currentLock);
            //取正向拨弄的锁
            sb.setCharAt(i, currentLock.charAt(i) == '9' ? '0' : (char) (currentLock.charAt(i) + 1));
            friend.offer(sb.toString());
            //取反向拨弄的锁
            sb.setCharAt(i, currentLock.charAt(i) == '0' ? '9' : (char) (currentLock.charAt(i) - 1));
            friend.offer(sb.toString());
        }
        return friend;
    }
}
		```

			

